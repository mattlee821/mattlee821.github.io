{
  "hash": "527aca0cd46884b41ed9410174100d3e",
  "result": {
    "engine": "knitr",
    "markdown": "---\ndate: \"2025-06-04\"\ndate-modified: last-modified\ndate-format: \"iso\"\ntitle: \"forest-fire model\"\ncategories: [shiny, app, model]\nimage: \"https://upload.wikimedia.org/wikipedia/commons/0/01/Forest_fire_model.gif\"\neditor: source\nexecute:\n  fig-path: \"posts/forest-fire/\"\neditor_options: \n  chunk_output_type: console\n---\n\nForest-fire models are not models of forest fires. Instead they're models through which we can explore dynamic systems. This is a simple `R` Shiny app that takes input probabilities for trees and fires; the app is rendered [here](https://mattlee.shinyapps.io/forestfire-model/) and was inspired by an [artist residency](https://www.bristol.ac.uk/public-engagement/case-studies/maths-made-art/).\n\nFirst we set the environment, including `N_grid` which is the size of our grid - `N_grid` = 1000 is equivalent to a `100x100` grid - and make a set of functions.\n\n::: {.cell}\n\n```{.r .cell-code}\n# environment ====\nlibrary(shiny)\nlibrary(ggplot2)\nlibrary(reshape2)\nN_grid <- 1000\n```\n:::\n\n\nThe 1st function is to create a grid (the land where trees grow)\n\n::: {.cell}\n\n```{.r .cell-code}\n# Initialize the grid \n# 0 = empty, 1 = tree, 2 = fire, 3 = cooling (empty but can't grow tree yet)\ndata_init_forest <- function(size) {\n  list(\n    grid = matrix(0, nrow = size, ncol = size),\n    stats = list(\n      total_trees = 0,\n      fires_started = 0,\n      trees_burned = 0\n    )\n  )\n}\n```\n:::\n\n\nThe 2nd function is for tree growth. We specify that trees can only grow on empty cells.\n\n::: {.cell}\n\n```{.r .cell-code}\n# Update empty cells to trees based on probability\ngrow_trees <- function(forest, p_growth) {\n  grid <- forest$grid\n  # Only grow trees in cells that are empty (0) but not cooling (3)\n  new_trees <- which(grid == 0 & runif(length(grid)) < (p_growth / N_grid))\n  \n  if (length(new_trees) > 0) {\n    grid[new_trees] <- 1\n    forest$stats$total_trees <- forest$stats$total_trees + length(new_trees)\n  }\n  \n  forest$grid <- grid\n  return(forest)\n}\n```\n:::\n\n\nThe 3rd function is for fires to start. We specify that fires can only start on cells with a tree.\n\n::: {.cell}\n\n```{.r .cell-code}\n# Start fires in trees based on probability\nstart_fires <- function(forest, p_fire) {\n  grid <- forest$grid\n  new_fires <- which(grid == 1 & runif(length(grid)) < (p_fire / N_grid))\n  \n  if (length(new_fires) > 0) {\n    grid[new_fires] <- 2\n    forest$stats$fires_started <- forest$stats$fires_started + length(new_fires)\n    forest$stats$trees_burned <- forest$stats$trees_burned + length(new_fires)\n  }\n  \n  forest$grid <- grid\n  return(forest)\n}\n```\n:::\n\n\nThe 4th function is for fires to spread. We specify that fires can only spread to adjacent cells if there is a tree already present. We also add that after one iteration a fire is converted to a cooling state (i.e., it can not be a tree or a new fire in the next iteration) to prevent a fire-loop and that a cooling state is converted to an empty state.\n\n::: {.cell}\n\n```{.r .cell-code}\n# Spread fire to adjacent trees and handle cooling\nspread_fire <- function(forest) {\n  grid <- forest$grid\n  size <- nrow(grid)\n  \n  # Find all fires\n  fires <- which(grid == 2, arr.ind = TRUE)\n  new_grid <- grid\n  \n  # Spread fire to adjacent trees\n  if (nrow(fires) > 0) {\n    for (i in 1:nrow(fires)) {\n      x <- fires[i, 1]\n      y <- fires[i, 2]\n      \n      # Check adjacent cells (up, down, left, right)\n      neighbors <- rbind(\n        c(x - 1, y), c(x + 1, y),\n        c(x, y - 1), c(x, y + 1)\n      )\n      \n      # Only consider valid grid coordinates\n      valid_neighbors <- neighbors[\n        neighbors[, 1] > 0 & neighbors[, 1] <= size &\n          neighbors[, 2] > 0 & neighbors[, 2] <= size, \n      ]\n      \n      # Convert adjacent trees to fires\n      for (n in 1:nrow(valid_neighbors)) {\n        if (grid[valid_neighbors[n, 1], valid_neighbors[n, 2]] == 1) {\n          new_grid[valid_neighbors[n, 1], valid_neighbors[n, 2]] <- 2\n          forest$stats$trees_burned <- forest$stats$trees_burned + 1\n        }\n      }\n    }\n  }\n  \n  # Convert fires to cooling state\n  new_grid[grid == 2] <- 3\n  # Convert cooling state to empty\n  new_grid[grid == 3] <- 0\n  \n  forest$grid <- new_grid\n  return(forest)\n}\n```\n:::\n\n\nWe make a simple sidebar layout Shiny app so we can adjust probabilities and see the model change dynamically. We also add some monitoring and print metrics so we can see the number of iterations and the cumulative number of trees grown, fires started, and trees burnt. \n\n::: {.cell}\n\n```{.r .cell-code}\n# testing ====\n# ui ====\nui <- fluidPage(\n  titlePanel(\"Forest Fire Model\"),\n  sidebarLayout(\n    sidebarPanel(\n      sliderInput(\"p_growth\", \"Tree Growth Probability (%)\", \n                  min = 0, max = 10, value = 5),\n      sliderInput(\"p_fire\", \"Fire Start Probability (%)\", \n                  min = 0, max = 10, value = 1),\n      actionButton(\"reset\", \"Reset Forest\"),\n      hr(),\n      h4(\"Statistics:\"),\n      textOutput(\"iterationCount\"),\n      textOutput(\"totalTrees\"),\n      textOutput(\"firesStarted\"),\n      textOutput(\"treesBurned\")\n    ),\n    mainPanel(\n      plotOutput(\"forestPlot\")\n    )\n  )\n)\n\n# server ====\nserver <- function(input, output, session) {\n  size <- 100\n  forest <- reactiveVal(data_init_forest(size))\n  iteration <- reactiveVal(0)\n  \n  autoUpdate <- reactiveTimer(200)\n  \n  observeEvent(input$reset, {\n    forest(data_init_forest(size))\n    iteration(0)\n  })\n  \n  observeEvent(autoUpdate(), {\n    current_forest <- forest()\n    iter <- iteration() + 1\n    \n    # First grow new trees (only in empty, non-cooling cells)\n    current_forest <- grow_trees(current_forest, input$p_growth)\n    \n    # Then start new fires\n    current_forest <- start_fires(current_forest, input$p_fire)\n    \n    # Finally spread existing fires and handle cooling\n    current_forest <- spread_fire(current_forest)\n    \n    forest(current_forest)\n    iteration(iter)\n  })\n  \n  output$forestPlot <- renderPlot({\n    forest_data <- melt(forest()$grid)\n    colnames(forest_data) <- c(\"x\", \"y\", \"state\")\n    \n    ggplot(forest_data, aes(x, y, fill = factor(state))) +\n      geom_tile() +\n      scale_fill_manual(values = c(\"black\", \"green3\", \"red2\", \"gray20\")) +\n      guides(fill = \"none\") +\n      theme_minimal() +\n      theme(axis.text = element_blank(),\n            axis.title = element_blank(),\n            axis.ticks = element_blank(),\n            panel.grid = element_blank())\n  })\n  \n  # Statistics outputs\n  output$iterationCount <- renderText({\n    paste(\"Iteration:\", iteration())\n  })\n  \n  output$totalTrees <- renderText({\n    paste(\"Total Trees grown:\", forest()$stats$total_trees)\n  })\n  \n  output$firesStarted <- renderText({\n    paste(\"Fires started:\", forest()$stats$fires_started)\n  })\n  \n  output$treesBurned <- renderText({\n    paste(\"Trees burned:\", forest()$stats$trees_burned)\n  })\n}\n\n# launch ====\nshinyApp(ui, server)\n```\n:::\n\n\n```{=html}\n <iframe id=\"example1\" src=\"https://mattlee.shinyapps.io/forestfire-model/\" style=\"border: none; width: 100%; height: 500px\" frameborder=\"0\"></iframe>\n```\n_This is an `iframe` of the rendered [app](https://mattlee.shinyapps.io/forestfire-model/); it takes a while to load and is choppy; it is interactive but mostly its for illustration_",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}