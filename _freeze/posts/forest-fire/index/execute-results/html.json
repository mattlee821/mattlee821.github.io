{
  "hash": "2d747ea16bc7b96f8a5877c397ffb02d",
  "result": {
    "engine": "knitr",
    "markdown": "---\ndate: \"2025-06-04\"\ndate-modified: last-modified\ndate-format: \"iso\"\ntitle: \"template\"\ncategories: [test, test and test]\nimage: https://raw.githubusercontent.com/quarto-dev/quarto-web/main/docs/get-started/hello/rstudio/lter_penguins.png\neditor: source\nexecute:\n  fig-path: \"posts/forest-fire/\"\neditor_options: \n  chunk_output_type: console\n---\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrm(list=ls())\nset.seed(821)\n\nlibrary(shiny)\nlibrary(ggplot2)\nlibrary(reshape2)\n\n# functions ====\n# Initialize the grid \n# 0 = empty, 1 = tree, 2 = fire, 3 = cooling (empty but can't grow tree yet)\ndata_init_forest <- function(size) {\n  list(\n    grid = matrix(0, nrow = size, ncol = size),\n    stats = list(\n      total_trees = 0,\n      fires_started = 0,\n      trees_burned = 0\n    )\n  )\n}\n\n# Update empty cells to trees based on probability\ngrow_trees <- function(forest, p_growth) {\n  grid <- forest$grid\n  # Only grow trees in cells that are empty (0) but not cooling (3)\n  new_trees <- which(grid == 0 & runif(length(grid)) < (p_growth / 1000))\n  \n  if (length(new_trees) > 0) {\n    grid[new_trees] <- 1\n    forest$stats$total_trees <- forest$stats$total_trees + length(new_trees)\n  }\n  \n  forest$grid <- grid\n  return(forest)\n}\n\n# Start fires in trees based on probability\nstart_fires <- function(forest, p_fire) {\n  grid <- forest$grid\n  new_fires <- which(grid == 1 & runif(length(grid)) < (p_fire / 1000))\n  \n  if (length(new_fires) > 0) {\n    grid[new_fires] <- 2\n    forest$stats$fires_started <- forest$stats$fires_started + length(new_fires)\n    forest$stats$trees_burned <- forest$stats$trees_burned + length(new_fires)\n  }\n  \n  forest$grid <- grid\n  return(forest)\n}\n\n# Spread fire to adjacent trees and handle cooling\nspread_fire <- function(forest) {\n  grid <- forest$grid\n  size <- nrow(grid)\n  \n  # Find all fires\n  fires <- which(grid == 2, arr.ind = TRUE)\n  new_grid <- grid\n  \n  # Spread fire to adjacent trees\n  if (nrow(fires) > 0) {\n    for (i in 1:nrow(fires)) {\n      x <- fires[i, 1]\n      y <- fires[i, 2]\n      \n      # Check adjacent cells (up, down, left, right)\n      neighbors <- rbind(\n        c(x - 1, y), c(x + 1, y),\n        c(x, y - 1), c(x, y + 1)\n      )\n      \n      # Only consider valid grid coordinates\n      valid_neighbors <- neighbors[\n        neighbors[, 1] > 0 & neighbors[, 1] <= size &\n          neighbors[, 2] > 0 & neighbors[, 2] <= size, \n      ]\n      \n      # Convert adjacent trees to fires\n      for (n in 1:nrow(valid_neighbors)) {\n        if (grid[valid_neighbors[n, 1], valid_neighbors[n, 2]] == 1) {\n          new_grid[valid_neighbors[n, 1], valid_neighbors[n, 2]] <- 2\n          forest$stats$trees_burned <- forest$stats$trees_burned + 1\n        }\n      }\n    }\n  }\n  \n  # Convert fires to cooling state\n  new_grid[grid == 2] <- 3\n  # Convert cooling state to empty\n  new_grid[grid == 3] <- 0\n  \n  forest$grid <- new_grid\n  return(forest)\n}\n\n\n# testing ====\n# ui ====\nui <- fluidPage(\n  titlePanel(\"Forest Fire Model\"),\n  sidebarLayout(\n    sidebarPanel(\n      sliderInput(\"p_growth\", \"Tree Growth Probability (%)\", \n                  min = 0, max = 10, value = 5),\n      sliderInput(\"p_fire\", \"Fire Start Probability (%)\", \n                  min = 0, max = 10, value = 1),\n      actionButton(\"reset\", \"Reset Forest\"),\n      hr(),\n      h4(\"Statistics:\"),\n      textOutput(\"iterationCount\"),\n      textOutput(\"totalTrees\"),\n      textOutput(\"firesStarted\"),\n      textOutput(\"treesBurned\")\n    ),\n    mainPanel(\n      plotOutput(\"forestPlot\")\n    )\n  )\n)\n\n# server ====\nserver <- function(input, output, session) {\n  size <- 100\n  forest <- reactiveVal(data_init_forest(size))\n  iteration <- reactiveVal(0)\n  \n  autoUpdate <- reactiveTimer(200)\n  \n  observeEvent(input$reset, {\n    forest(data_init_forest(size))\n    iteration(0)\n  })\n  \n  observeEvent(autoUpdate(), {\n    current_forest <- forest()\n    iter <- iteration() + 1\n    \n    # First grow new trees (only in empty, non-cooling cells)\n    current_forest <- grow_trees(current_forest, input$p_growth)\n    \n    # Then start new fires\n    current_forest <- start_fires(current_forest, input$p_fire)\n    \n    # Finally spread existing fires and handle cooling\n    current_forest <- spread_fire(current_forest)\n    \n    forest(current_forest)\n    iteration(iter)\n  })\n  \n  output$forestPlot <- renderPlot({\n    forest_data <- melt(forest()$grid)\n    colnames(forest_data) <- c(\"x\", \"y\", \"state\")\n    \n    ggplot(forest_data, aes(x, y, fill = factor(state))) +\n      geom_tile() +\n      scale_fill_manual(values = c(\"black\", \"green3\", \"red2\", \"gray20\")) +\n      guides(fill = \"none\") +\n      theme_minimal() +\n      theme(axis.text = element_blank(),\n            axis.title = element_blank(),\n            axis.ticks = element_blank(),\n            panel.grid = element_blank())\n  })\n  \n  # Statistics outputs\n  output$iterationCount <- renderText({\n    paste(\"Iteration:\", iteration())\n  })\n  \n  output$totalTrees <- renderText({\n    paste(\"Total Trees grown:\", forest()$stats$total_trees)\n  })\n  \n  output$firesStarted <- renderText({\n    paste(\"Fires started:\", forest()$stats$fires_started)\n  })\n  \n  output$treesBurned <- renderText({\n    paste(\"Trees burned:\", forest()$stats$trees_burned)\n  })\n}\n\n# launch ====\n```\n:::\n\n\n```{=html}\n <iframe id=\"example1\" src=\"https://mattlee.shinyapps.io/critical-speed-calculator/\" style=\"border: none; width: 100%; height: 720px\" frameborder=\"0\"></iframe>\n```",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}